import numpy as np
import math
import pandas as pd
import matplotlib.pyplot as plt
%matplotlib inline

class KMeans:
    def __init__(self, n_clusters=2, metric='euclidean', max_iter=300, tol=0.001):
        '''
        n_clusters - число кластеров
        metric - метрика
        max_iter - максимальное число итераций
        tol - расстояние между центрами, определяющее сходимость
        '''
        self.n_clusters = n_clusters
        self.metric = metric
        self.max_iter = max_iter
        self.tol = tol

    #@staticmethod
    
    def distance(self, vector1, vector2):
        if self.metric == 'euclidean':
            return math.sqrt(pow((vector2-vector1),2).sum())
        if self.metric == 'chebyshev':
            return abs(vector2-vector1).max()
        if self.metric == 'manhattan':
            return abs(vector2-vector1).sum()
        
        
    
    def predict(self, X):
        '''
        Предсказываем попадание объектов из X в конкретный кластер
        '''
        X=np.array(X)
        belong=np.zeros((len(X), 1))
        for i in range(0,X.shape[0]):
            min = self.distance(X[i],self.centers[0])
            belong[i] = 0
            for j in range(1,self.n_clusters):
                if self.distance(X[i],self.centers[j])<min:
                    min = self.distance(X[i],self.centers[j])
                    belong[i] = j
        self.labels = belong
        return belong
    

    def fit(self, X):
        centers = np.zeros((self.n_clusters, X.shape[1]))
        X=np.array(X)
        for i in range(0,self.n_clusters):
            centers[i] = X[math.floor(X.shape[0]*i/self.n_clusters):math.floor(X.shape[0]*(i+1)/self.n_clusters),:].sum(axis=0)*self.n_clusters/X.shape[0]
        
        '''
        Шаг 2 - Выполняем уточнение положения центров кластеров до тех пор, пока 
        не будет превышено значение max_iter или центры кластеров не будут меняться 
        '''
        for step in range(self.max_iter):            
            '''
            Шаг 2.1 - Вычисляем расстояние до цетров кластеров
            '''
            
            '''
            Шаг 2.2 - Для каждого объекта находим argmin от расстояний до центров
            '''
            belong=np.zeros((len(X), 1))
            for i in range(0,X.shape[0]):
                min = self.distance(X[i],centers[0])
                belong[i] = 0
                for j in range(1,self.n_clusters):
                    if self.distance(X[i],centers[j])<min:
                        min = self.distance(X[i],centers[j])
                        belong[i] = j
            X_new = np.concatenate((X,belong), axis=1)
            
            '''
            Шаг 2.3 - Уточняеням положения центров кластеров
            '''
            k=0
            for i in range(0,self.n_clusters):
                a = X_new[X_new[:,X.shape[1]] == i][:,:X.shape[1]].sum(axis=0)/X_new[X_new[:,X.shape[1]] == i].shape[0]
                if self.distance(centers[i,:],a)>self.tol:
                    k=1
                centers[i,:] = a
            if k==0:
                break;
        '''
        Шаг 3 - Сохраняем положения центров кластеров
        ''' 
        self.centers = centers
        
        '''
        Шаг 4 - Возвращяем предсказание
        '''        
        return self.predict(X)
        
data = pd.read_csv('dataset2.csv', sep='\t', header=None)
plt.plot(data[0],data[1],'o')
plt.show()

kmeans = KMeans(n_clusters = 3, max_iter=300, metric = 'euclidean').fit(data)
plt.figure()
plt.scatter(data[0].values,data[1].values, c=kmeans)
plt.show()